{
  "easy": [
    {
      "id": "react_e_01",
      "type": "multiple_choice",
      "question": "React에서 UI를 구성하는 기본 단위는?",
      "choices": ["Element", "Component", "Widget", "Template"],
      "answer": "Component",
      "answerIndex": 1,
      "explanation": "React의 기본 단위는 Component이며, 재사용 가능한 UI 블록을 의미합니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_e_02",
      "type": "multiple_choice",
      "question": "JSX는 어떤 언어의 확장 문법인가?",
      "choices": ["HTML", "CSS", "JavaScript", "XML"],
      "answer": "JavaScript",
      "answerIndex": 2,
      "explanation": "JSX는 JavaScript에 XML과 유사한 문법을 추가한 확장 문법입니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_e_03",
      "type": "multiple_choice",
      "question": "React 프로젝트를 생성하는 명령어는?",
      "choices": ["npm init react", "npx create-react-app", "npm start react", "react new"],
      "answer": "npx create-react-app",
      "answerIndex": 1,
      "explanation": "React 공식 CLI 도구는 create-react-app이며, npx 명령어로 실행됩니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_e_04",
      "type": "multiple_choice",
      "question": "React 앱을 실행하는 명령어는?",
      "choices": ["npm start", "npm run", "npm build", "npm dev"],
      "answer": "npm start",
      "answerIndex": 0,
      "explanation": "npm start 명령어는 로컬 개발 서버를 실행하여 앱을 미리볼 수 있게 합니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_e_05",
      "type": "multiple_choice",
      "question": "React에서 props는 어떤 역할을 하는가?",
      "choices": ["상태 저장", "컴포넌트 간 데이터 전달", "렌더링 제어", "이벤트 처리"],
      "answer": "컴포넌트 간 데이터 전달",
      "answerIndex": 1,
      "explanation": "props는 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하는 역할을 합니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_e_06",
      "type": "multiple_choice",
      "question": "React 개발 서버의 기본 포트 번호는?",
      "choices": ["8080", "3000", "5000", "4200"],
      "answer": "3000",
      "answerIndex": 1,
      "explanation": "create-react-app으로 생성된 React 앱은 기본적으로 포트 3000번을 사용합니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_e_07",
      "type": "multiple_choice",
      "question": "React에서 컴포넌트 이름은 어떤 규칙을 따라야 하는가?",
      "choices": ["소문자 시작", "대문자 시작", "언더바 시작", "숫자 가능"],
      "answer": "대문자 시작",
      "answerIndex": 1,
      "explanation": "React 컴포넌트는 대문자로 시작해야 JSX에서 올바르게 인식됩니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_e_08",
      "type": "multiple_choice",
      "question": "React에서 Fragment는 어떤 역할을 하는가?",
      "choices": ["DOM 노드 추가", "불필요한 태그 제거", "상태 초기화", "이벤트 등록"],
      "answer": "불필요한 태그 제거",
      "answerIndex": 1,
      "explanation": "Fragment는 추가적인 DOM 요소 없이 여러 엘리먼트를 묶을 때 사용됩니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_e_09",
      "type": "multiple_choice",
      "question": "React에서 이벤트 핸들러는 어떤 형태로 작성하는가?",
      "choices": ["문자열", "객체", "함수", "클래스"],
      "answer": "함수",
      "answerIndex": 2,
      "explanation": "React의 이벤트 핸들러는 함수를 전달하는 형태로 작성됩니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_e_10",
      "type": "multiple_choice",
      "question": "React 컴포넌트 파일의 확장자는 일반적으로 무엇인가?",
      "choices": [".java", ".jsx", ".py", ".json"],
      "answer": ".jsx",
      "answerIndex": 1,
      "explanation": "JSX 문법을 사용하는 React 컴포넌트는 .jsx 확장자를 주로 사용합니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    }
  ],
  "medium": [
    {
      "id": "react_m_01",
      "type": "multiple_choice",
      "question": "React에서 상태(state)를 관리하기 위해 사용하는 Hook은?",
      "choices": ["useRef", "useState", "useMemo", "useCallback"],
      "answer": "useState",
      "answerIndex": 1,
      "explanation": "useState Hook은 컴포넌트 내부에서 상태를 정의하고 변경할 수 있게 합니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_m_02",
      "type": "multiple_choice",
      "question": "useEffect Hook의 기본 용도는?",
      "choices": ["렌더링 후 부수 효과 처리", "상태 저장", "함수 메모이제이션", "컴포넌트 스타일링"],
      "answer": "렌더링 후 부수 효과 처리",
      "answerIndex": 0,
      "explanation": "useEffect는 렌더링 후 실행되어 API 호출, 이벤트 등록 등의 부수 효과를 처리합니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_m_03",
      "type": "multiple_choice",
      "question": "React에서 key 속성을 사용하는 이유는?",
      "choices": ["리스트 항목 식별", "스타일 적용", "상태 초기화", "DOM 제어"],
      "answer": "리스트 항목 식별",
      "answerIndex": 0,
      "explanation": "key 속성은 React가 리스트 항목을 식별하여 효율적으로 렌더링할 수 있게 합니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_m_04",
      "type": "multiple_choice",
      "question": "React Router에서 페이지 이동 시 사용하는 컴포넌트는?",
      "choices": ["<Route>", "<Link>", "<Nav>", "<Switch>"],
      "answer": "<Link>",
      "answerIndex": 1,
      "explanation": "React Router에서 <Link>는 a 태그 대신 페이지 이동에 사용됩니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_m_05",
      "type": "multiple_choice",
      "question": "Context API의 주요 목적은?",
      "choices": ["전역 상태 공유", "컴포넌트 렌더링 최적화", "API 요청 관리", "라우팅"],
      "answer": "전역 상태 공유",
      "answerIndex": 0,
      "explanation": "Context API는 props 전달 없이 컴포넌트 간 전역 상태를 공유할 수 있습니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_m_06",
      "type": "multiple_choice",
      "question": "useRef Hook은 어떤 값을 저장하는가?",
      "choices": ["상태 값", "불변 참조 값", "렌더링 결과", "이벤트 객체"],
      "answer": "불변 참조 값",
      "answerIndex": 1,
      "explanation": "useRef는 렌더링 간에도 유지되는 불변 참조 값을 저장할 수 있습니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_m_07",
      "type": "multiple_choice",
      "question": "useEffect를 처음 한 번만 실행하려면 두 번째 인자로 무엇을 전달해야 하는가?",
      "choices": ["null", "undefined", "[]", "[true]"],
      "answer": "[]",
      "answerIndex": 2,
      "explanation": "빈 배열([])을 전달하면 컴포넌트 마운트 시 한 번만 useEffect가 실행됩니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_m_08",
      "type": "multiple_choice",
      "question": "React의 Virtual DOM의 장점은?",
      "choices": ["메모리 절약", "변경된 부분만 효율적 렌더링", "코드 길이 단축", "라우팅 단순화"],
      "answer": "변경된 부분만 효율적 렌더링",
      "answerIndex": 1,
      "explanation": "Virtual DOM은 실제 DOM과 비교해 변경된 부분만 갱신함으로써 성능을 향상시킵니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_m_09",
      "type": "multiple_choice",
      "question": "상태(state) 변경 시 화면이 자동 갱신되는 이유는?",
      "choices": ["DOM 직접 수정", "Virtual DOM 비교", "CSS 리로딩", "서버 렌더링"],
      "answer": "Virtual DOM 비교",
      "answerIndex": 1,
      "explanation": "React는 Virtual DOM을 통해 변경된 부분만 다시 렌더링하여 화면을 자동 갱신합니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_m_10",
      "type": "multiple_choice",
      "question": "props가 변경되었을 때 컴포넌트가 다시 렌더링되는 이유는?",
      "choices": ["React 내부 비교 알고리즘 때문", "CSS 재적용 때문", "수동 호출 때문", "DOM 변경 때문"],
      "answer": "React 내부 비교 알고리즘 때문",
      "answerIndex": 0,
      "explanation": "React는 props 변화를 감지하여 필요 시 해당 컴포넌트를 다시 렌더링합니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    }
  ],
  "hard": [
    {
      "id": "react_h_01",
      "type": "multiple_choice",
      "question": "useMemo Hook의 주요 목적은?",
      "choices": ["렌더링 방지", "값 메모이제이션", "이벤트 최적화", "비동기 요청"],
      "answer": "값 메모이제이션",
      "answerIndex": 1,
      "explanation": "useMemo는 연산 비용이 큰 값을 메모이제이션하여 불필요한 계산을 방지합니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_h_02",
      "type": "multiple_choice",
      "question": "React.memo()는 어떤 컴포넌트에 사용되는가?",
      "choices": ["함수형 컴포넌트", "클래스형 컴포넌트", "모듈형 컴포넌트", "모든 형태"],
      "answer": "함수형 컴포넌트",
      "answerIndex": 0,
      "explanation": "React.memo는 함수형 컴포넌트를 메모이제이션하여 불필요한 렌더링을 방지합니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_h_03",
      "type": "multiple_choice",
      "question": "useCallback Hook의 주요 용도는?",
      "choices": ["함수 메모이제이션", "값 캐싱", "렌더링 방지", "상태 초기화"],
      "answer": "함수 메모이제이션",
      "answerIndex": 0,
      "explanation": "useCallback은 함수를 메모이제이션하여 동일 함수가 매번 새로 생성되는 것을 방지합니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_h_04",
      "type": "multiple_choice",
      "question": "React의 reconciliation 과정에서 key 속성이 중요한 이유는?",
      "choices": ["리스트 변경 탐지 효율 향상", "스타일 적용", "DOM 캐시 저장", "렌더링 순서 변경"],
      "answer": "리스트 변경 탐지 효율 향상",
      "answerIndex": 0,
      "explanation": "key는 React가 요소의 변경, 추가, 삭제를 빠르게 감지할 수 있게 도와줍니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_h_05",
      "type": "multiple_choice",
      "question": "React.StrictMode의 역할은?",
      "choices": ["잠재적 오류 감지", "렌더링 최적화", "서버 연결", "성능 향상"],
      "answer": "잠재적 오류 감지",
      "answerIndex": 0,
      "explanation": "StrictMode는 개발 중 잠재적 문제를 감지하기 위한 도구입니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_h_06",
      "type": "multiple_choice",
      "question": "서버 사이드 렌더링(SSR)의 주요 이점은?",
      "choices": ["초기 로딩 속도 향상", "서버 부하 증가", "네트워크 트래픽 감소", "JS 코드 최소화"],
      "answer": "초기 로딩 속도 향상",
      "answerIndex": 0,
      "explanation": "SSR은 서버에서 HTML을 생성하여 클라이언트의 초기 로딩 속도를 향상시킵니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_h_07",
      "type": "multiple_choice",
      "question": "React 18에서 도입된 Concurrent Rendering의 목적은?",
      "choices": ["UI 반응성 향상", "서버 성능 향상", "JS 크기 축소", "메모리 절약"],
      "answer": "UI 반응성 향상",
      "answerIndex": 0,
      "explanation": "Concurrent Rendering은 UI 응답성을 향상시키기 위한 렌더링 최적화 기술입니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_h_08",
      "type": "multiple_choice",
      "question": "Suspense 컴포넌트는 어떤 기능을 지원하는가?",
      "choices": ["지연 렌더링", "상태 공유", "라우팅", "테스트"],
      "answer": "지연 렌더링",
      "answerIndex": 0,
      "explanation": "Suspense는 비동기 로딩 중 로딩 UI를 표시하여 사용자 경험을 개선합니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_h_09",
      "type": "multiple_choice",
      "question": "React.lazy()는 어떤 기능을 제공하는가?",
      "choices": ["코드 스플리팅", "렌더링 최적화", "이벤트 바인딩", "상태 동기화"],
      "answer": "코드 스플리팅",
      "answerIndex": 0,
      "explanation": "React.lazy는 코드 스플리팅을 통해 필요한 컴포넌트만 로드합니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    },
    {
      "id": "react_h_10",
      "type": "multiple_choice",
      "question": "useLayoutEffect와 useEffect의 주요 차이점은?",
      "choices": ["실행 시점", "메모리 사용량", "렌더링 횟수", "JSX 처리 방식"],
      "answer": "실행 시점",
      "answerIndex": 0,
      "explanation": "useLayoutEffect는 DOM이 업데이트된 직후 실행되고, useEffect는 렌더링 완료 후 실행됩니다.",
      "userSelectedIndex": 0,
      "isWrong": false
    }
  ]
}
